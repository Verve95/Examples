#!/usr/bin/env python
# coding: utf-8

# # Исследование надёжности заёмщиков

# Изучим данные, которые переданы для работы над анализом.
# 

# ## Импорт библиотек

# In[1]:


import pandas as pd


# Прочитаем файл *data.csv* и сохраним его в переменной *df*. 

# In[2]:


df = pd.read_csv('/datasets/data.csv')


# Общая информация о данных таблицы *df*.

# In[3]:


df.info()


# Рассмотрим полученную информацию подробнее.
# 
# Всего в таблице 12 столбцов, тип данных у столбцов - *float64*, *int64*, *object*.
# 
# Подробно разберём, какие в df столбцы и какую информацию они содержат:
# 
# * children — количество детей в семье
# * days_employed — трудовой стаж в днях
# * dob_years — возраст клиента в годах
# * education — образование клиента
# * education_id — идентификатор образования
# * family_status — семейное положение
# * family_status_id — идентификатор семейного положения
# * gender — пол клиента
# * income_type — тип занятости
# * debt — имел ли задолженность по возврату кредитов
# * total_income — доход в месяц
# * purpose — цель получения кредита

# # Переработка данных

# Исключим пропуски, переименуем столбцы, а также проверим данные на наличие дубликатов.

# In[4]:


df.columns


# В названиях столбцов нету пробелов или же ошибок, с данными можно работать корректно.

# Проверим данные на наличие пропусков вызовом набора методов для суммирования пропущенных значений.

# In[5]:


df.isnull().sum()


# Пустые значения свидетельствуют, что для некоторых данных доступна не вся информация. Причины могут быть разные: скажем, не указана информация, либо же сама запись не корректна.

# В столбцах *df['days_employed']* и *df['total_income']* мы видим NaN, не целочисленные данные, а так же отрицательные значения.

# In[6]:


df['days_employed']


# Так как пустые значения в таблице находятся в столбцах *days_employed — трудовой стаж в днях* и *total_income — доход в месяц*, то заменяем пропущенные значения в *days_employed — трудовой стаж в днях* на *mean()* всего столбца, а *total_income — доход в месяц*, на *median()* всего столбца. После этой операции нужно убедиться, что таблица больше не содержит пропусков.

# In[7]:


df['days_employed'] = df['days_employed'].fillna(value = df['days_employed'].mean())
# <замена пропущенных значений в столбце 'days_employed' на среднее значение столбца>


# In[8]:


df['total_income'] = df['total_income'].fillna(value = df['total_income'].median())
# <замена пропущенных значений в столбце 'total_income' на медиану столбца>


# In[9]:


df.isnull().sum()
# <проверка на отсутствие>


# Получение первых 5 строк таблицы.

# In[10]:


df.head(5)


# Получение последних 5 строк таблицы.

# In[11]:


df.tail(5)


# Посмотрим список уникальных значений столбца *education*, так как в данном столбце видно, что одне и те же значения разным размером штрифта.

# In[12]:


df['education'].unique()


# Группируем данные по образованию и вызовом метода *count()* подсчитываем должности к образованию.

# In[13]:


df.groupby('education')['income_type'].count()
# <группировка данных таблицы df по столбцу 'education' и подсчёт количества значений столбца 'income_type'>


# Видим, что в таблице попадаются дубликаты, переведём их в нижний регистр через *lower()*.

# In[14]:


df['education'] = df['education'].str.lower()


# Сделаем повторный пересчёт столбца *education*, видим, что данные перераспределились по значениям с нижним регистром, теперь у нас остались только уникальные значения.

# In[15]:


df.groupby('education')['income_type'].count()


# Чтобы убедиться, что значения теперь корректно отображаются, выведим первые 5 строк.

# In[16]:


df.head(5)


# Столбцы *df['days_employed']*, *df['total_income']* состоят из типа данных *float64*, переведём его в *int64* для удобства просчёта.

# In[17]:


df['days_employed'] = df['days_employed'].astype('int')


# In[18]:


df['total_income'] = df['total_income'].astype('int')


# Выведим информацию о таблице и убедимся, что тип данных сменился на *int64*.

# In[19]:


df.info()


# Проверим столбец, сгрупируем и посмотрим присутсвуют ли в нем ошибки или некорректные данные.

# In[20]:


df.groupby('children')['income_type'].count()


# Мы нашли отрацательное значения (-1), а так же то, что у 76 человек в поле дети, указано колличество 20, что вызывает сомнения в достоверности данных, так что перепроверим и выведим часть данных этого значения.

# Для начала переведём через *abs()* значение (-1) в положительное (1), так как скорее всего была допущена ошибка при заполнения столбца.

# In[21]:


df['children'] = df['children'].abs()


# Так же поступим и со столбцом *df['days_employed']*, так как в данном столбце указаны как отрицательные, так и положительные данные, но он отвечает за "трудовой стаж работы в днях", поэтому скорее всего, что так же была допущена ошибка, так как данный показатель может быть или 0 или же иметь положительное значение.

# In[22]:


df['days_employed'] = df['days_employed'].abs()


# Вернёмся к категории у которой числится 20 детей, посмотрим, что указывают другие столбцы о данной категории.

# In[23]:


df.loc[df['children'] == 20]


# Видим, что есть те, кто "не женат/не замужем" и в возрасте 23 года завёл более 20-ти детей, вызывает сомнения данная категория. Скорее всего, либо опечатка, либо ошибка в выгрузке данных, и так как данные сомнения падают на 76 строчек, а это меньше 1% от общего количества, то заменим 20, на 2х детей.

# In[24]:


df['children'] = df['children'].replace(20, 2)


# Повторно выведим данные, сгрупировав значения и подсчитаем. Как видим в данном случае данные отправились в стобец к заёмщикам с 2-мя детьми.

# In[25]:


df.groupby('children')['income_type'].count()


# Необходимо установить наличие дубликатов.  Если найдутся, удаляем, и проверяем, все ли удалились.

# In[26]:


df.duplicated().sum()
# <получение суммарного количества дубликатов в таблице df>


# In[27]:


df = df.drop_duplicates().reset_index(drop=True)
# <удаление всех дубликатов из таблицы df специальным методом>


# In[28]:


df.duplicated().sum()
# <проверка на отсутствие>


# Дубликаты могли появиться вследствие сбоя в записи данных, либо при выгрузке из системы.

# Проверим, есть ли в столбцах *df['days_employed']*, *df['total_income']* на некорректиные строки.

# In[29]:


count_lines = 0
total_position = 0
wrong_lines = 0
for row in df['total_income']:
    try:
        count_lines += 1
        level = row
        total_position += level
    except:
        wrong_lines += 1
print('Количество измерений', count_lines)    
print('Количество некорректных строк', wrong_lines)


# In[30]:


count_lines = 0
total_position = 0
wrong_lines = 0
for row in df['days_employed']:
    try:
        count_lines += 1
        level = row
        total_position += level
    except:
        wrong_lines += 1
print('Количество измерений', count_lines)    
print('Количество некорректных строк', wrong_lines)


# Получаем общую информацию о данных. Убеждаемся, что чистка выполнена успешно.

# In[31]:


df.info()
# <получение общей информации о данных таблицы df>


# Так как в столбце *purpose — цель получения кредита* цели записаны в разной форме, необходимо провести леммматизацию и так как в данные указаны на русском языке, будет удобно и актуально использовать библиотеку *pymystem3*.

# Импортируем библиотеку и лемматизируем столбец *purpose*, вызвав функцию *lemmas*.

# In[32]:


from pymystem3 import Mystem
m = Mystem()

def lemmas(purpose):
    lemma = m.lemmatize(purpose)
    return lemma


# Выведим и добавим результат лемматизации столбца, добавив столбец *lemm_purpose*.

# In[33]:


df['lemm_purpose'] = df['purpose'].apply(lemmas)


# Проверим результат, получив первых 5 строк таблицы.

# In[34]:


df.head(5)


# Сощдадим функцию *lemm_category()*,которая будет принимать значения столбца(лемму) и возвращать категорию прнадлежности, после категоризируем данные столбца *lemm_purpose*, чтобы можно было определить тип цели получения кредита.

# In[35]:


def lemm_category(rows):
   
    if 'автомобиль' in rows:
        return 'автомобиль'
    if 'свадьба' in rows:
        return 'свадьба'
    if  'жилье' and 'ремонт' in rows:
        return 'ремонт жилья'
    if  'жилье' in rows:
        return 'жилье'
    if 'недвижимость' in rows:
        return 'недвижимость'   
    if 'образование' in rows:
        return 'образование'


# Выполнив функцию, добавим её результат в столбец *lemm_category*.

# In[36]:


df['lemm_category'] = df['lemm_purpose'].apply(lemm_category)


# Проверим результат, получив первых 5 строк таблицы, посморим на новый столбец и соответсвует ли он функции.

# In[37]:


df.head(5)


# Проверим сходятся ли наши значения и сохранены ли везле типы данных.

# Рассмотрим, на какие цели чаще всего берут кредит.

# In[38]:


df.groupby('lemm_category')['purpose'].count()


# In[39]:


df.info()
# <получение общей информации о данных таблицы df>


# Создадим функцию income(), которая будет принимать уровень дохода и возраващать индификатор, в зависимости от суммы.

# In[40]:


def income(income_value):
    if income_value < 50000:
        return 1
    if 50000 < income_value <= 100000:
        return 2
    if 100000 < income_value <= 150000:
        return 3
    if 150000 < income_value <= 200000:
        return 4
    if 200000 < income_value <= 250000:
        return 5
    if income_value > 250000:
        return 6


# Выполнив функцию, добавим её результат в столбец *income_type_id*.

# In[41]:


df['income_type_id'] = df['total_income'].apply(income)


# Проверим результат, получив первых 5 строк таблицы, посморим на новый столбец и соответсвует ли он функции.

# In[42]:


df.head(5)


# Проверим работу функции, как видим функция работает корректно и верно распределяет *id*.

# In[43]:


income(120000)


# Создадим функцию *income_name()*, которая будет принимать индификатор уровня дохода и возраващать пренадлежность, в зависимости от индификатора.

# In[44]:


def income_name(income_id):
    if income_id == 1:
        return 'Доход меньше 50 тыс'
    if income_id == 2:
        return 'Доход 50-100 тыс'
    if income_id == 3:
        return 'Доход 100-150 тыс'
    if income_id == 4:
        return 'Доход 150-200 тыс'
    if income_id == 5:
        return 'Доход 200-250 тыс'
    if income_id == 6:
        return 'Доход больше 250 тыс'


# Выполнив функцию, добавим её результат в столбец *income_sort*.

# In[45]:


df['income_sort'] = df['income_type_id'].apply(income_name)


# Проверим результат, получив первых 5 строк таблицы, посморим на новый столбец и соответсвует ли он функции.

# In[46]:


df.head(5)


# Проверим работу функции, как видим функция работает корректно и верно определяет *income_sort*.

# In[47]:


income_name(3)


# Создадим функцию *children_name()*, которая будет принимать количество детей и возраващать пренадлежность, в зависимости от количества.

# In[48]:


def children_name(children_id):
    if children_id == 0:
        return 'Без детей'
    if children_id == 1:
        return 'Один ребёнок'
    if children_id == 2:
        return 'Двое детей'
    if children_id == 3:
        return 'Трое детей'
    if children_id == 4:
        return 'Четверо детей'
    if children_id == 5:
        return 'Пятеро детей'


# Выполнив функцию, добавим её результат в столбец *children_sort*.

# In[49]:


df['children_sort'] = df['children'].apply(children_name)


# Проверим работу функции, как видим функция работает корректно и верно определяет *children_sort*.

# In[50]:


children_name(3)


# Проверим результат, получив первых 5 строк таблицы, посморим на новый столбец и соответсвует ли он функции.

# In[51]:


df.head(5)


#  

# # Анализ полученных данных

# Посмотрим, с каким доходом и какой целью кредита, чаще всего встречаются проблемы с выплатою в срок.

# In[52]:


money = df.pivot_table(index = 'income_sort' , columns = 'lemm_category', values = 'debt', aggfunc = 'sum')


# Отсортируем сводную таблицу.

# In[53]:


money.sort_values(by = 'income_sort', ascending = False)


# Как видно, самым проблематичным кредитом является цель связанная с автомобилем и недвижимостью, что ещё более интересно то, что довольно много просрочек у заёмщиков с доходом свыше 150 тыс.

# Рассмотрим, как разные цели кредита влияют на его возврат в срок?

# In[54]:


lemm_debt = df.pivot_table(index = 'lemm_category', values = 'debt', aggfunc='sum')


# Отсортируем сводную таблицу по убыванию.

# In[55]:


lemm_debt.sort_values(by = 'debt', ascending = False)


# Вывод таков, самыми "проблематичными" можно считать цели на "недвижимость" и "автомобиль", они возварщаются чаще всего не в нужный срок.

# Рассмотрим, *есть ли зависимость между наличием детей и возвратом кредита в срок?*

# In[56]:


child_debt = df.pivot_table(index = 'children_sort', values = 'debt', aggfunc='sum')


# Отсортируем сводную таблицу по убыванию.

# In[57]:


child_debt.sort_values(by = 'debt', ascending = False)


# Вывод таков, заёмщики, которые без детей или с одним ребёнком чаще всего возвращают кредит не в назначенный срок.

# В строке *пятеро детей* отсутствуют задолженности, проверим с чем это связанно. Проверим сколько вовсе данных заёмщиков.

# In[58]:


df.loc[df['children_sort'] == 'Пятеро детей']['children_sort'].count()


# В данном случае, заёмщиков из пятерью детьми, только лишь 9, можно предлоположить, что данная категория очень редко обращаются за получением кредита.

# Рассмотрим, *есть ли зависимость между семейным положением и возвратом кредита в срок?*

# In[59]:


family_debt = df.pivot_table(index = 'family_status', values = 'debt', aggfunc='sum')


# Отсортируем сводную таблицу по убыванию.

# In[60]:


family_debt.sort_values(by = 'debt', ascending = False)


# 

# Рассмотрим, *есть ли зависимость между уровнем дохода и возвратом кредита в срок?*

# In[61]:


income_sort_debt = df.pivot_table(index = 'income_sort', values = 'debt', aggfunc='sum')


# Отсортируем сводную таблицу по убыванию.

# In[62]:


income_sort_debt.sort_values(by = 'debt', ascending = False)


# Вывод таков, со всех категорий дохода чаще всего заёмщики, с доходом от 100 - 200 тыс, возвращают кредит не во время.

# # Результаты исследования

# Рабочие гипотизы и что удалось обнаружить:
# 
# * Чаще всего целью кредита являются: недвижимость/жилье, автомобиль и образование; 
# * Цели, которые чаще других не выплачиваются вовремя являются: недвижимость и автомобиль;
# * Заёмщики без детей чаще других не выплачивали кредит вовремя;
# * Клиенты, которые были женаты/замужем чаще других не выплачивали кредит вовремя;
# * Клиенты, с доходом 100-150 тыс чаще других не выплачивали кредит вовремя;
# 
# Общие результаты таковы, что на не вовремя выплаченный кредит влиет почти каждый фактор, начиная от количества детей, заканчивая целью кредита, мы проанализировали и дали ответ на основные вопросы (находится выше), так к примеру если и заёмщика доход около 70 тыс, это не значит, что он не сможет выплатить вовремя взятый кредит, так что не стоит опираться лишь на один из факторов, а подходить комплексно, изучая больше аспектов и важных факторов клиента.
# 
